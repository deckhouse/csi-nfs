---
title: "Модуль csi-nfs"
description: "Модуль csi-nfs: общие концепции и положения."
---

Модуль предоставляет CSI для управления NFS-томами и позволяет создавать StorageClass в Kubernetes через [пользовательские ресурсы Kubernetes](./cr.html#nfsstorageclass) `NFSStorageClass`.

{{< alert level="info" >}}
Создание StorageClass для CSI-драйвера `nfs.csi.k8s.io` пользователем запрещено.
{{< /alert >}}

## Системные требования и рекомендации

### Требования

- Используйте стоковые ядра, поставляемые вместе с [поддерживаемыми дистрибутивами](https://deckhouse.ru/documentation/v1/supported_versions.html#linux);
- Убедитесь в наличии развернутого и настроенного NFS-сервера;
- Для поддержки RPC-with-TLS включите в ядре Linux опции `CONFIG_TLS` и `CONFIG_NET_HANDSHAKE`.

### Рекомендации

Чтобы поды модуля перезапускались при изменении параметра `tlsParameters` в настройках модуля, должен быть включен модуль [pod-reloader](https://deckhouse.ru/products/kubernetes-platform/documentation/v1/modules/pod-reloader) (включен по умолчанию).

## Ограничения режима RPC-with-TLS

- Поддерживается только один центр сертификации (CA).
- Для политики безопасности `mtls` поддерживается только один сертификат клиента.
- Один NFS-сервер не может одновременно работать в разных режимах безопасности: `tls`, `mtls` и стандартный режим (без TLS).
- На узлах кластера не должен быть запущен демон `tlshd`, иначе он будет конфликтовать с демоном нашего модуля. Для предотвращения конфликтов при включении TLS на узлах автоматически останавливается сторонний `tlshd` и отключается его автозапуск.

## Быстрый старт

Все команды следует выполнять на машине, имеющей доступ к API Kubernetes с правами администратора.

### Включение модуля

1. Включите модуль `csi-nfs`.  Это приведет к тому, что на всех узлах кластера будет:
   - Зарегистрирован CSI драйвер;
   - Запущены служебные поды компонентов `csi-nfs`.

   ```yaml
   kubectl apply -f - <<EOF
   apiVersion: deckhouse.io/v1alpha1
   kind: ModuleConfig
   metadata:
     name: csi-nfs
   spec:
     enabled: true
     version: 1
   EOF
   ```

2. Дождитесь, когда модуль перейдет в состояние `Ready`:

   ```shell
   kubectl get module csi-nfs -w
   ```

### Создание StorageClass

Для создания StorageClass необходимо использовать ресурс [NFSStorageClass](./cr.html#nfsstorageclass). Пример создания ресурса:

```yaml
kubectl apply -f -<<EOF
apiVersion: storage.deckhouse.io/v1alpha1
kind: NFSStorageClass
metadata:
  name: nfs-storage-class
spec:
  connection:
    host: 10.223.187.3
    share: /
    nfsVersion: "4.1"
  reclaimPolicy: Delete
  volumeBindingMode: WaitForFirstConsumer
EOF
```

Для каждого PV будет создаваться каталог `<директория из share>/<имя PV>`.

### Проверка работоспособности модуля

Проверить работоспособность модуля можно [так](./faq.html#как-проверить-работоспособность-модуля)

### Затирание остаточных данных

Перед удалением на томе могут остаться файлы с пользовательскими данными. Эти файлы будут удалены и не будут доступны другим пользователям через NFS.

Однако данные удаленных файлов могут оказаться доступными другим клиентам, если сервер предоставит доступ к своему хранилищу на уровне блочных устройств.

Настроить процедуру очистки файлов перед удалением поможет опция `???`.

> **Внимание!** Эта опция не влияет на файлы уже удаленные клиентским приложением.

> **Внимание!** Эта опция влияет только на команды отправляемые по протоколу NFS. Проведение этих команд на стороне сервера определено
>
> - сервисом NFS сервера
> - файловой системой
> - уровнем блочных устройств и их виртуализации (например LVM)
> - самими физическими устройствами
>
> Убедитесь в доверенности сервера. Не отправляйте деликатные данные на сервера, в которых нет уверенности.

#### Опция `SinglePass`

Перезаписывает содержимое файлов случайной последовательностью перед удалением. Случайная последовательность передается по сети.

#### Опция `ThreePass`

Трижды перезаписывает содержимое файлов случайной последовательностью перед удалением. Три случайных последовательности передаются по сети. Имеет смысл только если сервер хранит данные на жестком диске, и есть риск, что у злоумышленника появится физический доступ к устройству.

#### Опция `Discard`

Многие файловые системы реализуют поддержку твердотельных накопителей, позволяя освободить место, занятое файлом, на блочном уровне без записи новых данных для увеличения срока службы твердотельного накопителя. Многие накопители гарантируют недоступность данных освобожденных блоков.

Опция `Discard` помечает содержимое файлов, как свободное через `FALLOC_FL_PUNCH_HOLE`. Файловая система освободит полностью используемые файлом блоки, через вызов `blkdiscard`, а остальное место будет перезаписано нулями. Если сервер сообщит, что `FALLOC_FL_PUNCH_HOLE` не поддерживается, то будет вызвана `FALLOC_FL_ZERO_RANGE`, которая занулит содержимое файла.

Преимущества этого метода:

- объем трафика не зависит от размера файлов, а только от их количества
- метод может обеспечить недоступность старых данных при многих конфигурациях сервера без применения спец средств
- работает как для жестких дисков, так и твердотельных накопителей
- позволяет увеличить время жизни твердотельного накопителя

TODO: Может разделим на две или три (PunchHole, ZeroOut, PunchHoleOrZeroOut)?
